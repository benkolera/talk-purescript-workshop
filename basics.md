# Purescript Basics

Purescript is a haskelly-like language that compiles down to javascript. Because it is based around
modules already, it can be exported JS files with either CommonJS or amd module definitions.

## Tooling and Building

### Bower

For better or worse, the purescript compiler actually ships with no std library or prelude, so
the purescript compiler by itself is actually useless (we don't even have numbers, strings or anything!).
To bring in dependencies, purescript has decided on bower. This is largely based on NPM 2's ugly handling
of sub dependencies ( http://harry.garrood.me/blog/purescript-why-bower/ ) and may change to NPM once
3 gets settled in, but for now know that any purescript application also needs bower!

### Psc 

Psc is the compile. You won't ever use it directly because you'll need to be using something that is 
including your bower dependencies in the build, but it's helpful to know how it works and how it emits
JS!

```
bkolera at Bens-MacBook-Pro in ~/src/talk-purescript-workshop (master●)
$ psc bower_components/purescript-prelude/src/Prelude.purs src/BasicsEx/ModulesAndFunctions.purs

bkolera at Bens-MacBook-Pro in ~/src/talk-purescript-workshop (master●)
$ cat output/ModulesAndFunctions/index.js
// Generated by psc version 0.7.6.1
"use strict";
var Prelude = require("Prelude");
var gimme5 = function (x) {
    return x + 5 | 0;
};
module.exports = {
    gimme5: gimme5
};
```

As you can see, with Ints it hasn't wrapped the value up in any crazy object or anything. It's 
one of purescripts goals to keep its primitives as close to JS as possible to make it easily 
callable from JS.

### Psci 

Psci is the purescript REPL. Again, like psc you'll need to use a higher level tool to actually
make it useable. We're going to use pulp for this.

The two most useful things are running code by hand and also inspecting the type of something.

```
bkolera at Bens-MacBook-Pro in ~/src/talk-purescript-workshop (master●)
$ pulp psci
 ____                 ____            _       _
 |  _ \ _   _ _ __ ___/ ___|  ___ _ __(_)_ __ | |_
 | |_) | | | | '__/ _ \___ \ / __| '__| | '_ \| __|
 |  __/| |_| | | |  __/___) | (__| |  | | |_) | |_
 |_|    \__,_|_|  \___|____/ \___|_|  |_| .__/ \__|
                                        |_|

:? shows help
> import Basics.ModulesAndFunctions
> gimme5 5
10

> :t gimme5
Int -> Int
```

### Webpack

Pulp provides a server mode that uses webpack which rebuilds on file changes but doesn't include
any way to livereload the webpage in the browser when you make a change. There's no way to fix
this without just rolling your own webpack conf, so that's what I've done! :)

The only thing that you may want to understand is that the entry point is defined in entry.js. It 
has some mess in it to convince webpack dev server to reload when we change a purs file, but it's
proper job is to run our Main.main function.

If you ever want one of your PS functions or modules out in the global context to play with in 
the browser, you could attach it to global here. 

Either way, know that there is very little magic here. No crazy runtimes or anything. Really its
just JS (and fairly readable JS at that).

## Modules, Functions and Reading Types

Make sure you are viewing src/BasicsEx/ModulesAndFunctions.purs!

This file is showing you how the basic module structure, imports and function definition work.

It's important to note that if you see a type signature like Int -> Int then it can't be doing
any side effects like mutating variables, changing the DOM or making decisions based on global
state. It must always return a value only based on the inputs you give it and the only thing it
can do is output a variable of it's output type. 

This is a very powerful thing to be able to have in your code, as being able to assert this means 
that you can easily reason about what a function does by it's types alone rather than having to
keep track of all the state it can mangle in your head. This works wonders for being able to 
safely compose and refactor code without having to load too much context into your head, which is
a very important thing when you're writing complicated code like text editors where unbridled 
mutating of the dom and state can make things very tricky to compose things without getting unexpected
bugs!

If you navigate to http://localhost:1337/#basics/modules_and_functions and look in the console,
you should see "Gimme five! 5". We're purposefully avoiding the DOM for the moment to get the
basics down pat!

## Data Types, Records and Pattern Matching

Please have src/BasicsEx/DataTypes.purs open and be looking at http://localhost:1337/#basics/data_types with 
the JS console open.

In this file we're going to figure out how to write our own data constructors and how to use them. There
are two main ways that we create a data type:

- A record (product type) with fields in it, like a normal JS object.
- A Sum Type, which is a type that has multiple different ways to construct it. Think of this like subtyping, but cooler.

There are two key bits of jargon you should know:
- A type is the thing that we use in our signatures which gives us our information about what the value is.
- A constructor is a way to construct a value of that type in our code. It is not a type itself. Sum types are just types with multiple constructors and aren't really a special case at all!

For both product and sum types, we can pattern match on them to extract data, even conditionally 
based on which constructor the value was constructed with.

## Effects

## Lists & Mapping them

## Lenses

## Further reading

https://leanpub.com/purescript/read#leanpub-auto-functions-and-records

https://leanpub.com/purescript/read#leanpub-auto-pattern-matching

https://leanpub.com/purescript/read#leanpub-auto-the-eff-monad

## Next, playing around with Thermite!

Scoot over to the [thermite.md|Examples] and see how you go! :)
